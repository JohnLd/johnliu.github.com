---
layout : post 
category : Android
tags : [Android]
desc : Glide介绍

title : Glide介绍
---

## Glide介绍
   
[原文地址，请戳这里！](http://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en)
   
## 导入项目
Picasso和Glide都放在jcenter， 你可以非常简单的在项目中添加依赖， 这是在Android Studio中的使用方式，eclipse不推荐继续使用。

### Picasso
```
dependencies {
    compile 'com.squareup.picasso:picasso:2.5.1'
}
```

### Glide
```
dependencies {
    compile 'com.github.bumptech.glide:glide:3.5.2'
    compile 'com.android.support:support-v4:22.0.0'
}
```

## 基础
正如我说的，Glide和Picasso非常的相似。它加载图片到ImageView的方法和Picasso是相同的。

### Picasso
{% highlight java %} 
Picasso.with(context)
    .load("http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg")
    .into(ivImg);
{% endhighlight %}

### Glide
{% highlight java %} 
Glide.with(context)
    .load("http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg")
    .into(ivImg);
{% endhighlight %}

尽管在细节上看似非常的相似，但Glide的设计要好很多。因为Glide初始化时，不仅支持Context，还支持Activity和Fragment, Context会自动从它们中获得。

![image](/content/images/glide/with.png)

传递Activity/Fragment给Glide的优点是：加载图片将会和Activity/Fragment的生命周期相结合。例如，当Activity/Fragment暂停的时候，会暂停加载，它唤醒的时候，会自动唤醒加载。所以，我鼓励你们如果可能的话，不要仅仅传递Context给Glide，而是使用Activity或者Fragment。

### 默认的Bitmap格式是RGB_565

这里有一个把1920x1080像素的图片，加载到768x432像素的ImageView的对比结果。

![image](/content/images/glide/firstload.jpg)

你可以发现Glide显示的图像质量要比Picasso的差。为什么呢？因为Glide的默认Bitmap格式是RGB_565, 其消耗的内存是使用ARGB_8888的50%。

下图是Picasso使用ARGB_8888和Glide使用RGB_565的内存消耗表。

![image](/content/images/glide/ram1_1.png)

如果你认为图片的显示质量已经很不错了，可以不用做任何事。但是如果觉得不可接受或者不能满足你的需求的话，你可以通过用新建一个实现了GlideModule接口的一个类，从而切换Bitmap格式为ARGB_8888.

{% highlight java %} 
public class GlideConfiguration implements GlideModule {

    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        // Apply options to the builder here.
        builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);
    }

    @Override
    public void registerComponents(Context context, Glide glide) {
        // register ModelLoaders here.
    }
}
{% endhighlight %}

然后在AndroidManifest.xml中添加一个meta-data。

{% highlight java %} 
<meta-data android:name="com.yourpackage.GlideConfiguration"
            android:value="GlideModule"/>
{% endhighlight %}

现在Glide的显示效果就好很多了！

![image](/content/images/glide/quality2.png)

让我们再看看内存效果表。这样看来，虽然Glide消耗的内存是之前的2倍，但是仍然比Picasso消耗的少很多。

![image](/content/images/glide/ram1_2.png)

这是因为Picasso把图像的全尺寸(1920x1080)加载到了内存中，然后让GPU实时修改大小和绘制。但是Glide采用了一种最佳实践方式，精确加载ImageView大小(768x432)的图像到内存中。如果使用Picasso的话，也可以通过resize()方法来实现相同的功能。

{% highlight java %} 
Picasso.with(this)
    .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg")
    .resize(768, 432)
    .into(ivImgPicasso);
{% endhighlight %}

但这样做的问题是，你必须自己手动计算ImageView的大小。或者如果你的ImageView设置了精确的大小(没有设置wrap_content)，你可以这样做。

{% highlight java %} 
Picasso.with(this)
    .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg")
    .fit()
    .centerCrop()
    .into(ivImgPicasso);
{% endhighlight %}

现在两者消耗的内存终于几乎一致了！

![image](/content/images/glide/memory3.png)

虽然两者消耗的内存基本相同了，但我不得不说，Glide在这个功能上确实比Picasso更强大，因为Glide可以在每个案例中自动计算ImageView大小。

### 图像质量的细节

下图的是我把ImageView放大到实际大小的结果。

![image](/content/images/glide/quality3.png)

值得注意的是，Glide的加载效果很粗糙，不像Picasso那样顺滑。直到现在，我仍然没有找到更直接的方式来改变图像调整的算法。

此时你是否疑问，Glide不怎么好呢？